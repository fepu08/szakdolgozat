from collections import defaultdict
from typing import Any
from surprise import accuracy
import numpy as np


class Metrics:
    """A module to get accuracy and behavioral metrics"""

    @staticmethod
    def mean_error():
        return None

    @staticmethod
    def mean_absolute_error(predictions, verbose=False):
        return accuracy.mae(predictions, verbose)

    @staticmethod
    def mean_squared_error(predictions, verbose=False):
        return accuracy.mse(predictions, verbose)

    @staticmethod
    def root_mean_squared_error(predictions, verbose=False):
        return accuracy.rmse(predictions, verbose)

    @staticmethod
    def hit_rate(
        top_n_recommendations: defaultdict[Any, list],
        predictions_for_left_out_items: list,
    ) -> float:
        """
        Calculates the hit rate based on top-N recommendations and LOOCV testset.

        Parameters:
                top_n_recommendations: A defaultdict where the keys are the user IDs and a list of predicted items (movie_id, rating) as values.
                predictions_for_left_out_items:  A list of :class:`Prediction<surprise.prediction_algorithms.predictions.Prediction>` objects
                that contains all the estimated ratings, generated by LOOCV, where each object contains (user_id, movie_id, r_ui, est, {'was_impossible'}).

        Returns:
                The hit rate as a float.
        """
        num_of_hits = 0
        total = len(predictions_for_left_out_items)

        if total < 1:
            return None

        # Iterate through the LOOCV test set to check if the left-out item is in the top-N predictions
        for user_id, left_out_movie_id, r_ui, est, _ in predictions_for_left_out_items:
            predicted_movies = [
                movie_id for movie_id, _ in top_n_recommendations[user_id]
            ]
            if left_out_movie_id in predicted_movies:
                num_of_hits += 1

        return num_of_hits / total

    @staticmethod
    def coverage():
        return None

    @staticmethod
    def diversity():
        return None

    @staticmethod
    def novelty(
        recommendations: defaultdict[Any, list],
        popularity_rankings: defaultdict[int, int],
    ):
        """
                Computes the novelty for a set of recommendations.

                Parameters:
                - recommendations (defaultdict): A dictionary where keys are user IDs and values are lists of tuples, each containing a recommended movie ID and its estimated rating.
                        All lists are assumed to have the same length (top-N recommendations).
                - popularity_rankings (defaultdict): A dictionary where keys are movie IDs and values are the occurrence count of each item in the training data.

                Returns:
                        - float: The system-level novelty of the recommendations.
                        - list: The item-level novelty (self-information) of the recommendations for each recommended top-N list.

        Reference: https://github.com/statisticianinstilettos/recmetrics/blob/master/recmetrics/metrics.py
        """
        number_of_recommendations = len(next(iter(recommendations.values())))
        total_occurrences_of_all_items = sum(popularity_rankings.values())
        mean_self_information = []

        for userID, sublist in recommendations.items():
            self_information = 0
            for itemID in sublist:
                # Calculate self-information for each item
                item_popularity = (
                    popularity_rankings.get(itemID, 1) / total_occurrences_of_all_items
                )
                self_information += -np.log2(item_popularity)
            # Normalize self-information by the length of the recommendation list for the current user
            mean_self_information.append(self_information / number_of_recommendations)

        system_level_novelty = np.mean(mean_self_information)

        return system_level_novelty, mean_self_information
